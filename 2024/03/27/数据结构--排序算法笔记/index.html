<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构--排序算法笔记 | Luvmand</title><meta name="author" content="Ari"><meta name="copyright" content="Ari"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="冒泡排序原理从左到右依次比较相邻元素大小，将更大的元素放在右边，经过一组比较后最后一个元素一定是最大元素； 从头开始重新进行从左到右的比较，由于前一轮已经是最大的元素，故不需要参与比较，每轮结束都会减少一个参与比较的元素； 每轮结束都会得到一个最大值，并以从右往左从大到小确定元素的顺序，直到排序结束。 动图演示 代码12345678910111213141516171819202122void s">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构--排序算法笔记">
<meta property="og:url" content="https://arigreat.github.io/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Luvmand">
<meta property="og:description" content="冒泡排序原理从左到右依次比较相邻元素大小，将更大的元素放在右边，经过一组比较后最后一个元素一定是最大元素； 从头开始重新进行从左到右的比较，由于前一轮已经是最大的元素，故不需要参与比较，每轮结束都会减少一个参与比较的元素； 每轮结束都会得到一个最大值，并以从右往左从大到小确定元素的顺序，直到排序结束。 动图演示 代码12345678910111213141516171819202122void s">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://arigreat.github.io/img/default_cover/iscream.jpg?6294">
<meta property="article:published_time" content="2024-03-27T09:47:22.000Z">
<meta property="article:modified_time" content="2024-04-01T08:40:01.888Z">
<meta property="article:author" content="Ari">
<meta property="article:tag" content="Note">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="排序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://arigreat.github.io/img/default_cover/iscream.jpg?6294"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://arigreat.github.io/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构--排序算法笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-01 16:40:01'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://cdn.jsdelivr.net/combine/gh/dylanNew/live2d/webgl/Live2D/lib/live2d.min.js,npm/pixi.js@6.5.2/dist/browser/pixi.min.js,npm/pixi-live2d-display/dist/index.min.js,gh/Weidows-projects/Live2dLoader/dist/Live2dLoader.min.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="gear-loader"><div class="gear-loader_overlay"></div><div class="gear-loader_cogs"><div class="gear-loader_cogs__top"><div class="gear-top_part"></div><div class="gear-top_part"></div><div class="gear-top_part"></div><div class="gear-top_hole"></div></div><div class="gear-loader_cogs__left"><div class="gear-left_part"></div><div class="gear-left_part"></div><div class="gear-left_part"></div><div class="gear-left_hole"></div></div><div class="gear-loader_cogs__bottom"><div class="gear-bottom_part"></div><div class="gear-bottom_part"></div><div class="gear-bottom_part"></div><div class="gear-bottom_hole"></div></div></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/HTML/kobe/index.html"><i class="fa-fw fas fa-gift"></i><span> 子页面</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_cover/iscream.jpg?6294')"><nav id="nav"><span id="blog-info"><a href="/" title="Luvmand"><span class="site-name">Luvmand</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/HTML/kobe/index.html"><i class="fa-fw fas fa-gift"></i><span> 子页面</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构--排序算法笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-27T09:47:22.000Z" title="发表于 2024-03-27 17:47:22">2024-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-01T08:40:01.888Z" title="更新于 2024-04-01 16:40:01">2024-04-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">编程笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构--排序算法笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从左到右依次比较相邻元素大小，将更大的元素放在右边，经过一组比较后最后一个元素一定是最大元素；</p>
<p>从头开始重新进行从左到右的比较，由于前一轮已经是最大的元素，故不需要参与比较，每轮结束都会减少一个参与比较的元素；</p>
<p>每轮结束都会得到一个最大值，并以从右往左从大到小确定元素的顺序，直到排序结束。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> Cnt, Idx = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//n个数排n-1次</span></span><br><span class="line">	<span class="keyword">for</span> (Cnt = <span class="number">0</span>; Cnt &lt; n - <span class="number">1</span>; Cnt++)</span><br><span class="line">	&#123;	<span class="comment">//去除排序完成的末位数</span></span><br><span class="line">		<span class="keyword">for</span> (Idx = <span class="number">0</span>; Idx &lt; n - Cnt - <span class="number">1</span>; Idx++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[Idx] &gt; arr[Idx + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(arr, Idx, Idx + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>冒泡排序属于交换排序，是稳定排序。</p>
<p><strong>平均时间复杂度为O(n²)</strong>,最差为O(n²),最好为O(n)</p>
<p>空间复杂度为O(1)。</p>
<hr>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>首先在未排序的序列中找到最小(大)元素，放在排序序列的起始位置；</p>
<p>再从剩余未排序元素中继续寻找最小(大)元素，放在已排序序列的末尾；</p>
<p>重复第二步直到全部排序完毕。</p>
<h2 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//找到目前最小值</span></span><br><span class="line">            min = j;    <span class="comment">//记录最小值</span></span><br><span class="line">            swap(&amp;arr[min], &amp;arr[i]);&#125;   <span class="comment">//做交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h2><p>选择排序是一种简单直观的排序算法；</p>
<p><strong>任何数据的时间复杂度都是O(n²) ;</strong> </p>
<p>空间复杂度为O(1)。</p>
<hr>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>插入排序类似于给扑克牌排序。通过构建有序数列，将未排序的元素从后往前找位置并插入。</p>
<p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。</p>
<h2 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/insertionSort.gif" alt="insertionSort"></p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j,key;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                key = arr[i];</span><br><span class="line">                j=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (arr[j]&gt;key)) &#123;</span><br><span class="line">                        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h2><p>**平均时间复杂度为O(n²)**，最差为O(n²)，最好为O(n);</p>
<p>空间复杂度O(1)。</p>
<hr>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序，也称<strong>缩小增量排序</strong>，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>先将整个待排序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p>
<p>子序列的构成不是简单地“逐段分割”，将相隔某个增量的记录组成一个子序列，<strong>让增量逐趟缩短，直到增量为 1 为止</strong>。</p>
<p>将数组中每间隔为d的元素划分为同一组，然后对每一组使用插入排序。d有多个值，但要求最后一个值为1，即最后一次要进行插入排序。例如数组：2 9 1 3 6 3，如果d为2，那么2、1、6为一组；9、3、3为一组；对每组都进行插入排序。</p>
<h2 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序"></p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shell_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, gap, tmp;</span><br><span class="line">    <span class="comment">//&quot;len &gt;&gt; 1&quot;表示将&quot;len&quot;二进制的值右移一位，相当于将&quot;len&quot;除以2并取整</span></span><br><span class="line">	<span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap = gap &gt;&gt; <span class="number">1</span>)&#123;<span class="comment">//gap依次减小</span></span><br><span class="line">		<span class="keyword">for</span> (i = gap; i &lt; len; i++)&#123;<span class="comment">//每次插排右边待插入的数</span></span><br><span class="line">			tmp = arr[i];</span><br><span class="line">			<span class="comment">//这段就是插排，只是每次和前面相距gap长的数比，不是和前面每一个比</span></span><br><span class="line">			<span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; tmp; j -= gap)<span class="comment">//注意边界条件的判断</span></span><br><span class="line">			&#123;</span><br><span class="line">				arr[j] = arr[j - gap];</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h2><p>*<em>时间复杂度为O(n</em>logn)**，比O(n²) 更优；</p>
<p>空间复杂度为常数阶 O(1)。</p>
<hr>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是冒泡排序的改进版，使用了<strong>分治法</strong>。它也属于交换排序，通过元素之间的位置交换来达到排序的目的。</p>
<h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>从数列中挑出一个元素，称为 “基准”;</p>
<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作；</p>
<p>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>选择基准并分区操作：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/快速排序1.png" alt="快速排序1" style="zoom: 67%;">

<p>对子数列递归排序：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/快速排序2.jpg" alt="快速排序2" style="zoom:50%;">

<h2 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/快速排序.gif" alt="快速排序" style="zoom: 150%;">

<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = start, j = end;</span><br><span class="line">	<span class="type">int</span> temp = arr[start];  <span class="comment">//基准数</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (i&lt;j &amp;&amp; arr[j] &gt;= temp)  <span class="comment">//从右向左，找小于temp的</span></span><br><span class="line">			&#123;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; j)     <span class="comment">//填坑</span></span><br><span class="line">			&#123;</span><br><span class="line">				arr[i] = arr[j];</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">while</span> (i&lt;j &amp;&amp; arr[i] &lt; temp)  <span class="comment">//从左向右，找大于temp的</span></span><br><span class="line">			&#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; j)      <span class="comment">//填坑</span></span><br><span class="line">			&#123;</span><br><span class="line">				arr[j] = arr[i];</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[i] = temp;                  <span class="comment">//把基准数放到 i=j 位置</span></span><br><span class="line">		QuickSort(arr, start, i - <span class="number">1</span>);   <span class="comment">//左半部分快排 </span></span><br><span class="line">		QuickSort(arr, i + <span class="number">1</span>, end);     <span class="comment">//右半部分快排</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h2><p>*<em>平均时间复杂度：O(n</em>logn)**；最坏情况：O(n²)；</p>
<p><em>快速排序O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</em></p>
<p>空间复杂度：O (logn)。</p>
<hr>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序是建立在归并操作上的有效排序算法，以分治法为特点。</p>
<h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>将两个或两个以上的<strong>有序表</strong>组合成一个新的有序表，简单操作就是<strong>将这几个有序表中的最小元素移入新数据段的末尾</strong>，使之有序。</p>
<p>假如初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为 1。然后两两归并，得到 n&#x2F;2 个长度为 2 或 1 的有序子序列；再两两归并，……，如此重复，直到得到一个长度为 n 的有序序列为止，这种排序方法称为 <strong>二路归并排序</strong>，下文介绍的也是这种排序方式。</p>
<h2 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> L, <span class="type">int</span> M, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">	<span class="type">int</span> LEFT_SIZE = M - L + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> RIGHT_SIZE = R - M;</span><br><span class="line">	<span class="type">int</span> *left = (<span class="type">int</span> *)<span class="built_in">malloc</span>(LEFT_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//开辟左子数组</span></span><br><span class="line">	<span class="built_in">memset</span>(left, <span class="number">0</span>, LEFT_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="type">int</span> *right = (<span class="type">int</span> *)<span class="built_in">malloc</span>(RIGHT_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//开辟右子数组</span></span><br><span class="line">	<span class="built_in">memset</span>(right, <span class="number">0</span>, RIGHT_SIZE * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	<span class="comment">// 以 M 为分割线，把原数组分成左右子数组</span></span><br><span class="line">	<span class="keyword">for</span> (i = L; i &lt;= M; i++) &#123;left[i - L] = arr[i];&#125;</span><br><span class="line">	<span class="keyword">for</span> (j = M + <span class="number">1</span>; j &lt;= R; j++) &#123;right[j - M - <span class="number">1</span>] = arr[j];&#125;</span><br><span class="line">	<span class="comment">// 再合并成一个有序数组（从两个序列中选出最小值依次插入）</span></span><br><span class="line">	i = <span class="number">0</span>; j = <span class="number">0</span>; k = L;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; LEFT_SIZE &amp;&amp; j &lt; RIGHT_SIZE)&#123;arr[k++] = left[i] &lt; right[j] ? left[i++] : right[j++];&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; LEFT_SIZE) &#123;arr[k++] = left[i++];&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; RIGHT_SIZE) &#123;arr[k++] = right[j++];&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="built_in">free</span>(left);</span><br><span class="line">	left = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">free</span>(right);</span><br><span class="line">	right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> L, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == R) <span class="keyword">return</span>; <span class="comment">//递归终止条件，分无可分</span></span><br><span class="line">	<span class="comment">// 将 arr[L..R] 平分为 arr[L..M] 和 arr[M+1..R].</span></span><br><span class="line">	<span class="type">int</span> M = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//（分别递归地将子序列排序为有序数列）先分割到最小子区间，再反过来一步步合并成一个完整有序数组</span></span><br><span class="line">	merge_sort(arr, L, M);<span class="comment">//左边</span></span><br><span class="line">	merge_sort(arr, M + <span class="number">1</span>, R);<span class="comment">//右边</span></span><br><span class="line">	<span class="comment">// 将两个排序后的子序列再归并到 arr</span></span><br><span class="line">	merge(arr, L, M, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h2><p>归并排序是<strong>稳定排序</strong>，它和选择排序一样，性能不受输入数据的影响，但表现比选择排序更好；</p>
<p><strong>时间复杂度始终为 O(nlogn)，</strong>但它需要额外的内存空间；</p>
<p><strong>空间复杂度为 O(n)。</strong></p>
<hr>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ol>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列。</li>
</ol>
<h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>实现堆排序需要解决两个问题：</p>
<ul>
<li>如何将一个无序序列构建成堆？</li>
<li>如何在输出堆顶元素后，调整剩余元素成为一个新的堆？</li>
</ul>
<p>以升序为例，算法实现的思路为：</p>
<ol>
<li>建立一个 build_heap 函数，将数组 tree[0,…n-1] 建立成堆，n 表示数组长度。函数里需要维护的是所有节点的父节点，最后一个子节点下标为 n-1，那么它对应的父节点下标就是 (n-1-1)&#x2F;2。</li>
<li>构建完一次堆后，最大元素就会被存放在根节点 tree[0]。将 tree[0] 与最后一个元素交换，每一轮通过这种不断将最大元素后移的方式，来实现排序。</li>
<li>而交换后新的根节点可能不满足堆的特点了，因此需要一个调整函数 heapify 来对剩余的数组元素进行最大堆性质的维护。如果 tree[i] 表示其中的某个节点，那么 tree[2<em>i+1] 是左孩子，tree[2</em>i+2] 是右孩子，选出三者中的最大元素的下标，存放于 max 值中，若 max 不等于 i，则将最大元素交换到 i 下标的位置。但是，此时以 tree[max] 为根节点的子树可能不满足堆的性质，需要递归调用自身。</li>
</ol>
<h2 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数组转化成大顶堆/小顶堆的形式，然后每次把堆顶元素放在数组最后，再堆化，循环至数组完全有序</span></span><br><span class="line"><span class="comment">//已知父节点下标i,则左子节点下标2*i+1,右子节点下标2*i+2；</span></span><br><span class="line"><span class="comment">//已知孩子节点下标i,则其父节点下标为(i-1)/2 结果直接取整(小数位丢弃)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调整剩余元素，构成大顶堆(全是根据遍历父节点来调整每一个二叉部分)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> tree[], <span class="type">int</span> n, <span class="type">int</span> parent)</span>&#123;</span><br><span class="line">	<span class="comment">//n 表示序列长度，i 表示父节点下标</span></span><br><span class="line">	<span class="keyword">if</span> (parent &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//左侧子节点下标</span></span><br><span class="line">	<span class="type">int</span> left = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//右侧子节点下标</span></span><br><span class="line">	<span class="type">int</span> right = <span class="number">2</span> * parent + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> max = parent;</span><br><span class="line">	<span class="keyword">if</span> (left &lt; n &amp;&amp; tree[left] &gt; tree[max]) max = left;</span><br><span class="line">	<span class="keyword">if</span> (right &lt; n &amp;&amp; tree[right] &gt; tree[max]) max = right;</span><br><span class="line">	<span class="keyword">if</span> (max != parent)&#123;<span class="comment">//如果最大值不是当前父节点，则交换最大值到上面，并继续递归调用调整下面相连的子二叉树</span></span><br><span class="line">		swap(tree, max, parent);</span><br><span class="line">		heapify(tree, n, max); <span class="comment">//递归调整被交换的下一个父亲节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组下标当作完全二叉树每个节点下标来处理（从左至右，从上至下排序号）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">build_heap</span><span class="params">(<span class="type">int</span> tree[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="comment">//树最后一个节点下标</span></span><br><span class="line">	<span class="type">int</span> last_node = n - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//确定最后一个节点 的 父节点下标</span></span><br><span class="line">	<span class="type">int</span> parent = (last_node - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//开始从最后一个父节点开始，往前遍历每个父节点，并调整值的顺序，最终当前最大值会到堆顶</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//第一次构建大顶堆需要遍历所有父节点，后面每次调整只要传入根节点即可（里面会递归调整发生值改变的所在子二叉树）</span></span><br><span class="line">	<span class="keyword">for</span> (i = parent; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		heapify(tree, n, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_sort</span><span class="params">(<span class="type">int</span> tree[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="comment">//构建堆</span></span><br><span class="line">	build_heap(tree, n);</span><br><span class="line">	<span class="type">int</span> i; <span class="comment">//i代表最后一个元素下标，也是当前未调整的数组长度</span></span><br><span class="line">	<span class="comment">//每次将堆化好的堆顶元素放到最后，并调整剩下的元素</span></span><br><span class="line">	<span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="comment">// 将堆顶元素与最后一个元素交换</span></span><br><span class="line">		swap(tree, i, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//调整大顶堆（剩下的元素），永远保证大顶堆有序</span></span><br><span class="line">		heapify(tree, i, <span class="number">0</span>); <span class="comment">//构建好堆以后 每次调整，只要传入根节点0即可</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h2><p>堆排序是<strong>不稳定排序</strong>，适合数据量较大的序列；</p>
<p>**平均时间复杂度为Ο(nlogn)**；</p>
<p>空间复杂度为O(1)。</p>
<hr>
<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序的核心在于<strong>将输入的数据值转化为键存储在额外开辟的数组空间中</strong>。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>找出待排序数组的最大最小元素</p>
<p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</p>
<p>统计完成后，将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p>
<h2 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, arr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counting_sort</span><span class="params">(<span class="type">int</span> *ini_arr, <span class="type">int</span> *sorted_arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> *count_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                count_arr[ini_arr[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] += count_arr[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                sorted_arr[--count_arr[ini_arr[j - <span class="number">1</span>]]] = ini_arr[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">free</span>(count_arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> *arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="type">int</span> *sorted_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                arr[i] = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ini_array: &quot;</span>);</span><br><span class="line">        print_arr(arr, n);</span><br><span class="line">        counting_sort(arr, sorted_arr, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sorted_array: &quot;</span>);</span><br><span class="line">        print_arr(sorted_arr, n);</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        <span class="built_in">free</span>(sorted_arr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h2><p><strong>当输入的元素是 n 个 0 到 r 之间的整数时，它的时间复杂度为 O(n + r)。</strong>计数排序不是比较排序。计数排序是<strong>稳定排序</strong>，适合数据范围不显著大于数据数量的序列。</p>
<p>占用额外内存，还需要 r 个桶，因此空间复杂度是 O(n+r)，计数排序快于任何比较排序算法，但这是通过牺牲空间换取时间来实现的。</p>
<hr>
<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序是计数排序的升级版。</p>
<h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序。最后拼接非空的桶内数据，得到最终结果。</p>
<h2 id="动图演示-8"><a href="#动图演示-8" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="桶排序"></p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bucket_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || r &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据最大/最小元素和桶数量，计算出每个桶对应的元素范围</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; arr[i]) max = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (min &gt; arr[i]) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> range = (max - min + <span class="number">1</span>) / r + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立桶对应的二维数组，一个桶里最多可能出现 n 个元素</span></span><br><span class="line">    <span class="type">int</span> buckets[r][n];</span><br><span class="line">    <span class="built_in">memset</span>(buckets, <span class="number">0</span>, <span class="keyword">sizeof</span>(buckets));</span><br><span class="line">    <span class="type">int</span> counts[r];</span><br><span class="line">    <span class="built_in">memset</span>(counts, <span class="number">0</span>, <span class="keyword">sizeof</span>(counts));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> k = (arr[i] - min) / range;</span><br><span class="line">        buckets[k][counts[k]++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="comment">// 分别对每个非空桶内数据进行排序，比如计数排序</span></span><br><span class="line">        <span class="keyword">if</span> (counts[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        counting_sort(buckets[i], counts[i]);</span><br><span class="line">        <span class="comment">// 拼接非空的桶内数据，得到最终的结果</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; counts[i]; j++) &#123;</span><br><span class="line">            arr[index++] = buckets[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h2><p>桶排序是<strong>稳定排序</strong>，但仅限于桶排序本身，假如桶内排序采用了快速排序之类的非稳定排序，那么就是不稳定的；</p>
<p>桶排序的时间复杂度和桶内的排序方法相关。</p>
<p>桶排序占用额外内存，需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以桶排序的空间复杂度为 O(n+r)；</p>
<hr>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><p>基数排序将整数每一位拆开，从个位数向高位展开，依次比较并排序。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>第一次排序比较个位：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F1.webp" alt="基数排序1"></p>
<p>第二次排序比较十位，由于在第一次排序中确定了个位的大小排序位置为<strong>从上往下从小到大</strong>，第二次比较后，同一个桶中的结果排序一定是正确的，因为桶中的元素十位相同，个位排列<strong>从上往下从小到大</strong>。排序完成后十位后面有序：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F2.webp" alt="基数排序2"></p>
<p>第三次排序比较百位，百位后面有序：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F3.webp" alt="基数排序3"></p>
<p>而最后一次的时候进行处理的时候，千位有的数字需要补零，这次完毕后后千位及以后都有序，即整个序列排序完成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F4.webp" alt="基数排序4"></p>
<h2 id="动图演示-9"><a href="#动图演示-9" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基数，范围0~9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">radix_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取最大值和最小值</span></span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i, j, l;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; arr[i]) max = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (min &gt; arr[i]) min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假如序列中有负数，所有数加上一个常数，使序列中所有值变成正数</span></span><br><span class="line">    <span class="keyword">if</span> (min &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) arr[i] -= min;</span><br><span class="line">        max -= min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取最大值位数</span></span><br><span class="line">    <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        max /= RADIX;</span><br><span class="line">        d ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">queue</span>[RADIX][n];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">queue</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="type">int</span> count[RADIX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">        <span class="comment">// 分配数据</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> key = arr[j] % (<span class="type">int</span>)<span class="built_in">pow</span>(RADIX, i + <span class="number">1</span>) / (<span class="type">int</span>)<span class="built_in">pow</span>(RADIX, i);</span><br><span class="line">            <span class="built_in">queue</span>[key][count[key]++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收集数据</span></span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RADIX; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; count[j]; l++) &#123;</span><br><span class="line">                arr[c++] = <span class="built_in">queue</span>[j][l];</span><br><span class="line">                <span class="built_in">queue</span>[j][l] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假如序列中有负数，收集排序结果时再减去前面加上的常数</span></span><br><span class="line">    <span class="keyword">if</span> (min &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) arr[i] += min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h2><p>基数排序是<strong>稳定排序</strong>，适用于关键字取值范围固定的排序；</p>
<p>假设给定 n 个数，它的最高位数是 d，基数（也就是桶的个数）为 r，那么可以这样理解：共进行 d 趟排序，每趟排序都要对 n 个数据进行分配，再从 r 个桶中收集回来。所以算法的时间复杂度为 O(d(n+r))，在整数的排序中，r &#x3D; 10，因此可以简化成 O(dn)，是<strong>线性阶</strong>的排序。</p>
<p>需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以基数排序的空间复杂度为 O(n+r)。</p>
<h2 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h2><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶，适用于非负整数间的排序，且最大值和最小值尽可能接近；</li>
<li>计数排序：每个桶只存储单一键值，适用于最大值和最小值尽可能接近的排序；</li>
<li>桶排序：每个桶存储一定范围的数值，适用于元素尽可能分布均匀的排序。</li>
</ul>
<hr>
<br>

<br>

<p>参考资料:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/All_In_gzx_cc/article/details/116046535">【基础知识】十大排序算法详解（C语言版）_大排序算法 c语言-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0 十大经典排序算法 | 菜鸟教程 (runoob.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://arigreat.github.io">Ari</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://arigreat.github.io/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">https://arigreat.github.io/2024/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://arigreat.github.io" target="_blank">Luvmand</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Note/">Note</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover/iscream.jpg?6294" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="数据结构--基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/sakura3.jpg?1692" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构--基础知识</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/27/hexo-butterfly/" title="Hexo-Butterfly设计参考"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/sakura3.jpg?8195" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hexo-Butterfly设计参考</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="数据结构--基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/sakura3.jpg?1692" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-01</div><div class="title">数据结构--基础知识</div></div></a></div><div><a href="/2024/04/16/AJAX%E6%95%99%E7%A8%8B/" title="AJAX笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/sakura2.jpg?6051" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-16</div><div class="title">AJAX笔记</div></div></a></div><div><a href="/2024/03/19/JS%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/" title="JS笔记--函数"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/sakura3.jpg?6488" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-19</div><div class="title">JS笔记--函数</div></div></a></div><div><a href="/2024/04/11/C++STL%E5%AE%B9%E5%99%A8/" title="C++ STL容器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/miku2.jpg?8123" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-11</div><div class="title">C++ STL容器</div></div></a></div><div><a href="/2024/03/27/hexo-butterfly/" title="Hexo-Butterfly设计参考"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/sakura3.jpg?8195" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-27</div><div class="title">Hexo-Butterfly设计参考</div></div></a></div><div><a href="/2024/04/06/hexo%E6%B7%BB%E5%8A%A0html%E9%A1%B5%E9%9D%A2/" title="Hexo添加HTML页面和图片失效问题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/miku2.jpg?6398" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-06</div><div class="title">Hexo添加HTML页面和图片失效问题</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ari</div><div class="author-info__description">Love is all you need</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/arigreat"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/arigreat" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:ariiii666@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA"><span class="toc-number">1.2.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA-1"><span class="toc-number">2.2.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-number">2.4.</span> <span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA-2"><span class="toc-number">3.2.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">3.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-2"><span class="toc-number">3.4.</span> <span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA-3"><span class="toc-number">4.2.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">4.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-3"><span class="toc-number">4.4.</span> <span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">5.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">5.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA-4"><span class="toc-number">5.3.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">5.4.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-4"><span class="toc-number">5.5.</span> <span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-number">6.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA-5"><span class="toc-number">6.2.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">6.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-5"><span class="toc-number">6.4.</span> <span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-6"><span class="toc-number">7.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA-6"><span class="toc-number">7.2.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">7.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-6"><span class="toc-number">7.4.</span> <span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-7"><span class="toc-number">8.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA-7"><span class="toc-number">8.2.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-number">8.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-7"><span class="toc-number">8.4.</span> <span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-8"><span class="toc-number">9.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA-8"><span class="toc-number">9.2.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-number">9.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-8"><span class="toc-number">9.4.</span> <span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">10.</span> <span class="toc-text">基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-9"><span class="toc-number">10.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">10.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA-9"><span class="toc-number">10.3.</span> <span class="toc-text">动图演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-number">10.4.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-9"><span class="toc-number">10.5.</span> <span class="toc-text">算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-vs-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-vs-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">10.6.</span> <span class="toc-text">基数排序 vs 计数排序 vs 桶排序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/29/Python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AE%9E%E7%8E%B0/" title="Python爬虫的简单实现"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/miku1.png?4653" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python爬虫的简单实现"/></a><div class="content"><a class="title" href="/2024/04/29/Python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E5%AE%9E%E7%8E%B0/" title="Python爬虫的简单实现">Python爬虫的简单实现</a><time datetime="2024-04-29T15:52:26.000Z" title="发表于 2024-04-29 23:52:26">2024-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/20/music_soundMakeYouCry/" title="Now and then you miss it, sounds make you cry"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/miku2.jpg?1805" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Now and then you miss it, sounds make you cry"/></a><div class="content"><a class="title" href="/2024/04/20/music_soundMakeYouCry/" title="Now and then you miss it, sounds make you cry">Now and then you miss it, sounds make you cry</a><time datetime="2024-04-20T08:06:34.000Z" title="发表于 2024-04-20 16:06:34">2024-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/16/AJAX%E6%95%99%E7%A8%8B/" title="AJAX笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/sakura2.jpg?6051" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AJAX笔记"/></a><div class="content"><a class="title" href="/2024/04/16/AJAX%E6%95%99%E7%A8%8B/" title="AJAX笔记">AJAX笔记</a><time datetime="2024-04-16T14:23:00.000Z" title="发表于 2024-04-16 22:23:00">2024-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/11/C++STL%E5%AE%B9%E5%99%A8/" title="C++ STL容器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover/miku2.jpg?8123" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ STL容器"/></a><div class="content"><a class="title" href="/2024/04/11/C++STL%E5%AE%B9%E5%99%A8/" title="C++ STL容器">C++ STL容器</a><time datetime="2024-04-11T05:34:51.000Z" title="发表于 2024-04-11 13:34:51">2024-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/11/music_morale/" title="Mr.Morale的十八次心理咨询"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/mrMorale.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mr.Morale的十八次心理咨询"/></a><div class="content"><a class="title" href="/2024/04/11/music_morale/" title="Mr.Morale的十八次心理咨询">Mr.Morale的十八次心理咨询</a><time datetime="2024-04-10T16:07:34.000Z" title="发表于 2024-04-11 00:07:34">2024-04-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Ari</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'sFhjXzh7S7dqr5ehMabX0lSo-MdYXbMMI',
      appKey: 'snRODvctjs9f9y2w6tqjBQrE',
      avatar: 'monsterid',
      serverURLs: 'https://cloud.luvmand.top',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: '827efcb6581b2e5e8b95',
      clientSecret: '2015daabee730144197fa7928b8de62380eb51e7',
      repo: 'arigreat.github.io',
      owner: 'arigreat',
      admin: ['arigreat'],
      id: 'c7fe40e6b010913d4b6f541e02c11a53',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Valine' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/js/sakura.js"></script><script>addEventListener("DOMContentLoaded",function(){let models_1=[{scale:0.07,width:500,height:400,left:'-4vw',bottom:'0vh',role:"https://cdn.jsdelivr.net/gh/alg-wiki/AzurLaneL2DViewer@gh-pages/assets/lafei_4/lafei_4.model3.json",background:"",opacity:1,mobile:false,draggable:false,},];new Live2dLoader(models_1)})</script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>